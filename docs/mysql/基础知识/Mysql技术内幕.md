

## MYSQL 技术内幕

查看 Mysql 版本：

命令行下: `mysql -V`

sql 查询: `select version();`

### MYSQL 体系结构和存储引擎

#### 1.定义数据库和数据库实例

**数据库**：`磁盘`上的文件或者`内存`中记录的文件。

**实例**：数据库后台线程和内存组成。可以操作数据库文件。

集群情况下，一个数据库可以被多个实例使用，多个实例操作数据库文件。



**配置加载顺序**

都出现的配置参数以最后的为准

```sh
mysql --help|grep my.cnf
```

![mysql配置加载顺序](https://i.loli.net/2020/02/25/qionUVumYPQvLzD.png)





#### 2.MYSQL 存储引擎

​		InnoDB 存储引擎支持事务，其特点是行锁设计、支持外键，并支持类似于 Oracle 的非锁定读，即默认读取操作不会产生锁。InnoDB 通过使用多版本并发控制 (MVCC) 来获得高并发性，并且实现了 SQL 标准的 4 种隔离级别，默认为 REPEATABLE 级别。针对 OLTP （主要是基本的、日常的事务处	理，记录即时的增、删、改、查，比如在银行存取一笔款，就是一个事务交易） 

​	MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些 OLAP（复杂的分析操作）

##### 2.1 InnoDB 存储引擎

![1583743587944](https://i.loli.net/2020/03/09/kTqgG9m3whrCNOK.png)

后台线程负责刷新内存池中的数据。此外将修改的数据刷新到磁盘文件，同时保证数据库发生异常 InnoDB 能恢复到正常的运行状态。

###### 2.1.1 后台线程

- Master Thread

  核心后台线程，刷新数据到磁盘，包括脏页的刷新、合并插人缓冲、UNDO 页的回收

- IO Thread

  write、read、insert buffer、log thread

- Purge Thread

  事务被提交后，其所使用的 undolog 可能不再需要，因此需要 PurgeThread 来回收已经使用并分配的 undo 页。

- Page Cleaner Thread

  将脏页的刷新操作都放人到单独的线程中来完成，其目的是为了减轻原 Master Thread 的工作

###### 2.1.2 内存

1. **缓冲池**

   查询：将页`FIX`在缓冲池中，下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。

   修改：首先修改在缓冲池中的页，然后再以一定的频率刷
   新到磁盘上。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为 Checkpoint 的机制刷新回磁盘。同样，这也是为了提高数
   据库的整体性能。

   具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲
   (insert buffer)、自适应哈希索引( adaptive hash index)、InnoDB 存储的锁信息(lock
   info)、数据字典信息(data dictionary) 等。不能简单地认为，缓冲池只是缓存索引页和
   数据页，它们只是占缓冲池很大的一部分而已。

   ![内存数据对象](https://i.loli.net/2020/03/09/swPFeVJnRljCGpm.png)

2. **LRU list、Free List、Flush List**

   通常来说，数据库中的缓冲池是通过 LRU (Latest Recent Used，最近最少使用) 算法来进行管理的。即最频繁使用的`页(16k)`在 LRU 列表的前端，而最少使用的页在
   LRU 列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放 LRU 列表中尾端的页。

   Innodb 优化后：LRU 中位插入策略，插入到末尾 37% 约 正向 5/8 左右，可配置。

   数据库刚启动时，LRU list 为空，所有的页存放在 Free list 中，申请空闲页。

   压缩页：减少空间，降低 IO，针对读操作多，SSD 昂贵，很有用。压缩后页大小小于 16k，称为脏页（和磁盘页大小不一致）

3. **重做日志缓存**

   Master Thread 每秒、每个事务提交、日志缓存剩余空间小于一半都会刷新到外部磁盘的重做日志文件中。

4. **CheckPoint (检查点) 技术**

   将缓冲池中脏页的数据刷回到磁盘，每次刷新多少页到磁盘，每次从哪里取脏页，LSN (Log Sequence Number) 标记版本。

###### 2.1.3 Insert Buffer

指的不是内存中的 insert buffer，这个是和数据页一样的物理页。数据结构是一棵 B+ 树，提升性能。

> InnoDB 存储引擎开创性地设计了 Insert Buffer，对于`非聚集索引`的插人或更新操作,
> 不是每一次直接插人到索引页中，而是先判断插人的非聚集索引页是否在缓冲池中，若在，则直接插人；若不在，则先放人到一个 Insert Buffer 对象中。数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge (合并)操作，这时通
> 常能将多个插人合并到一个操作中(因为在一个索引页中),这就大大提高了对于非聚
> 集索引插人的性能。

简单理解，插入数据时先插入得到 Inser Buffer 里面，再易一定频率刷到磁盘。针对的是`非聚集索引`（非唯一，唯一的需要在跑一次查询无法减少 IO）的插入和更新。缺点：极端情况下，宕机后恢复大量的 Insert Buffer到实际的非聚集索引中要很久。

###### 2.1.4 两次写 （Double Write）

如果脏页写入磁盘过程中宕机，可能数据 16k 写了 4k，也可能数据文件损坏（redolog 也无法恢复），这些情况下数据就丢失了。

写磁盘前先备份页的副本，失败由副本恢复。保证了数据的可靠性。



##### 2.2 MyISAM 存储引擎


