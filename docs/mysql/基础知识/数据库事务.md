###### 1.数据库事务的四大特性以及事务的隔离级别

- `原子性`：要么全部成功，要么全部失败回滚
- `一致性`：比如两个用户转钱，无论怎么转，最后总额肯定一样。
- `隔离性`：多个线程操作后台会隔离
- `持久性`：事务完毕后哪怕数据库宕机重启后还是一样。

###### 2.事务的隔离级别

- `脏读`：一个事务读取另一个事务未提交的数据。
- `不可重复读`：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
- `幻读`：幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。
- `序列化`：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 

###### 3.MySQL数据库为我们提供的四种隔离级别

- ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。性能不好！


- ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。保证一个事务不能读取另一个事务未提交的数据。`(默认)`
- ③ Read committed (读已提交)：可避免脏读的发生。
- ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

查看 Mysql 数据库事务隔离级别

```sql
1.查看当前会话隔离级别
select @@tx_isolation;
2.查看系统当前隔离级别
select @@global.tx_isolation;
3.设置当前会话隔离级别
set session transaction isolatin level repeatable read;
4.设置系统当前隔离级别
set global transaction isolation level repeatable read;
```

###### 4.事务的传播级别

- 大概就是在一个事务内，对子方法的事务级别进行控制，如创建一个新的事务。

  > 注意的是：动态代理给spring留下的坑！spring中使用都是无效的，需要创建上下文对象application执行子方法，或者使用aopContext代理，也或者是spring注入对象调用才生效。

