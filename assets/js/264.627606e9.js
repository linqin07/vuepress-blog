(window.webpackJsonp=window.webpackJsonp||[]).push([[264],{657:function(t,a,_){"use strict";_.r(a);var i=_(20),v=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"为什么接口要实现impl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么接口要实现impl"}},[t._v("#")]),t._v(" 为什么接口要实现Impl")]),t._v(" "),a("h6",{attrs:{id:"_1-解耦"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-解耦"}},[t._v("#")]),t._v(" 1.解耦")]),t._v(" "),a("p",[t._v("抽象出service层也是为了更好的控制"),a("code",[t._v("事务")]),t._v("吧，将持久化和业务分开。")]),t._v(" "),a("h6",{attrs:{id:"_2-面向接口编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-面向接口编程"}},[t._v("#")]),t._v(" 2.面向接口编程")]),t._v(" "),a("h6",{attrs:{id:"_3-代理方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-代理方式"}},[t._v("#")]),t._v(" 3.代理方式")]),t._v(" "),a("p",[t._v("一、简单来说：")]),t._v(" "),a("ul",[a("li",[t._v("JDK 动态代理只能对实现了接口的类生成代理，而不能针对类")]),t._v(" "),a("li",[t._v("CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）")])]),t._v(" "),a("p",[t._v("二、Spring在选择用JDK还是CGLiB的依据：")]),t._v(" "),a("ul",[a("li",[t._v("Bean实现接口时，Spring就会用JDK的动态代理")]),t._v(" "),a("li",[t._v("当Bean没有实现接口时，Spring使用CGlib是实现")])]),t._v(" "),a("p",[t._v("三、CGlib比JDK快？")]),t._v(" "),a("ul",[a("li",[t._v("使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。")]),t._v(" "),a("li",[t._v("在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);