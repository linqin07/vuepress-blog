(window.webpackJsonp=window.webpackJsonp||[]).push([[267],{660:function(a,s,_){"use strict";_.r(s);var t=_(20),v=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"防止表单重复提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#防止表单重复提交"}},[a._v("#")]),a._v(" 防止表单重复提交")]),a._v(" "),s("h6",{attrs:{id:"_1-按钮js变灰"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-按钮js变灰"}},[a._v("#")]),a._v(" 1.按钮js变灰")]),a._v(" "),s("p",[a._v("使用"),s("code",[a._v("js")]),a._v("在点击操作后把按钮不可用。缺点，如果不支持jq或者懂行的可以跳过验证。")]),a._v(" "),s("h6",{attrs:{id:"_2-页面重定向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-页面重定向"}},[a._v("#")]),a._v(" 2.页面重定向")]),a._v(" "),s("p",[a._v("如果业务允许的情况下，点击了就重定向跳转到对应的成功页面。")]),a._v(" "),s("h6",{attrs:{id:"_3-推荐-使用表单隐藏域记录session信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-推荐-使用表单隐藏域记录session信息"}},[a._v("#")]),a._v(" 3."),s("code",[a._v("（推荐）")]),a._v("使用表单隐藏域记录session信息")]),a._v(" "),s("p",[a._v("加载页面时附带session信息放于页面隐藏标签内，提交时一起提交。服务端处理后"),s("code",[a._v("移除")]),a._v("服务器端的session信息。可以最有效的防止表单重复提交。")]),a._v(" "),s("h6",{attrs:{id:"_4-数据库添加唯一索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-数据库添加唯一索引"}},[a._v("#")]),a._v(" 4.数据库添加唯一索引")]),a._v(" "),s("p",[a._v("在数据库添加唯一索引，可以保证没有其他的垃圾数据入库。缺点：数据库压力会增加。")]),a._v(" "),s("h3",{attrs:{id:"幂等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幂等"}},[a._v("#")]),a._v(" 幂等")]),a._v(" "),s("p",[a._v("作用是保证数据的一致性、准确性")]),a._v(" "),s("ol",[s("li",[a._v("防止表单重复提交，按钮变灰、页面重定向、表单隐藏域移除")]),a._v(" "),s("li",[a._v("有幂等要求的接口，增加使用token判断重复请求")]),a._v(" "),s("li",[a._v("数据库各种锁机制，乐观锁、悲观锁。唯一约束")]),a._v(" "),s("li",[a._v("业务层可以使用锁，jvm Lock、分布式锁等")])]),a._v(" "),s("h3",{attrs:{id:"hashmap-原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-原理"}},[a._v("#")]),a._v(" HashMap 原理")]),a._v(" "),s("p",[a._v("JDK1.7 的 HashMap 是由数组+链表构成的，新增一个数通过哈希算法，计算出对应存放在数组的某个位置，如果这个位置已经存在数据了，也就是说存在了哈希冲突，这时候 JDK1.7 就将新增的数和原来的数构成一个链表放在数组这个位置，后面冲突的数依次都放入链表中")]),a._v(" "),s("p",[a._v("2、通常解决哈希冲突有两种办法，上面所说的通过链表的形式称为"),s("code",[a._v("链地址法")]),a._v("；还有一种方法称为开放地址法，也就是说如果存在哈希冲突了，那么将新增的值在用一个新的哈希算法算出所存的位置插入，但是这还会构成二次冲突，三次冲突.....")]),a._v(" "),s("p",[a._v("3、JDK1.8的HashMap是由数组+链表+红黑树构成（平衡二叉树，AVL树），当"),s("code",[a._v("链表长度超过8会自动转换成红黑树，红黑树节点个数小于6")]),a._v("，又自动转换为链表。这是为了提高检索效率（红黑树检索效率明显是高于链表的）")]),a._v(" "),s("h5",{attrs:{id:"为什么链表转红黑树的阈值是-8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么链表转红黑树的阈值是-8"}},[a._v("#")]),a._v(" 为什么链表转红黑树的阈值是 8？")]),a._v(" "),s("p",[a._v("我们平时在进行方案设计时，必须考虑的两个很重要的因素是：时间和空间。对于 HashMap 也是同样的道理，简单来说，阈值为 8 是在时间和空间上权衡的结果。红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价不值得。理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率遵循泊松分布，按照"),s("code",[a._v("泊松分布")]),a._v("的公式计算，链表中节点个数为8时的概率为 0.00000006，这个概率足够低了，并且到 8 个节点时，红黑树的性能优势也会开始展现出来，因此 8 是一个较合理的数字。")]),a._v(" "),s("h5",{attrs:{id:"为什么-hashmap-的负载因子默认为-0-75"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-hashmap-的负载因子默认为-0-75"}},[a._v("#")]),a._v(" 为什么 HashMap 的负载因子默认为 0.75")]),a._v(" "),s("p",[a._v("在 HashMap 的类注释上有如图一段解释：大致意思是说负载因子是 0.75 的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。")])])}),[],!1,null,null,null);s.default=v.exports}}]);