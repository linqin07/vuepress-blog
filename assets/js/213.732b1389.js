(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{608:function(t,a,e){"use strict";e.r(a);var r=e(20),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"spring事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring事务"}},[t._v("#")]),t._v(" Spring事务")]),t._v(" "),a("p",[t._v("在一般的项目中，开启了声明式事务就是在Service调用方法头上加一个注解"),a("code",[t._v("@Transactional")]),t._v("，\n但是其实里面有很多异常的情况。")]),t._v(" "),a("ul",[a("li",[a("h6",{attrs:{id:"正常情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正常情况"}},[t._v("#")]),t._v(" 正常情况")]),t._v(" "),a("p",[t._v("当删除操作出现了异常，能正常回滚。")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t@Transactional(propagation=Propagation.REQUIRED)\n\tpublic boolean delete(int id) {\n\t\tboolean result = mapper.delete(id);\n\t\treturn result;\n\t}\n")])])]),a("ul",[a("li",[a("h6",{attrs:{id:"已有try-catch处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#已有try-catch处理"}},[t._v("#")]),t._v(" 已有try-catch处理")])])]),t._v(" "),a("p",[t._v("该增加操作不能回滚，原因是抛出的异常被自己内部的try-catch处理掉了，没有往外抛出。spring当作成功的例子直接插入数据库了。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('@Transactional(propagation=Propagation.REQUIRED)\n\tpublic void save(User user) {\n\t\ttry {\n\t\t\tmapper.save(user);\n\t\t\tthrow new Exception("异常");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n')])])]),a("ul",[a("li",[a("h6",{attrs:{id:"特定异常回滚"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特定异常回滚"}},[t._v("#")]),t._v(" 特定异常回滚")])])]),t._v(" "),a("p",[a("code",[t._v("rollbackFor")]),t._v("可以指定异常的类型回滚。\n"),a("code",[t._v("noRollbackFor")]),t._v("指定异常不回滚")]),t._v(" "),a("p",[t._v("生产中，经常有全局异常统一管理，而 spring 默认的事务回滚是针对 "),a("code",[t._v("runtimeException")]),t._v("，导致很多想回滚的都失效了，此时需要指定回滚异常类型。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//定异常的类型回滚。\n@Transactional(rollbackFor=ArithmeticException.class)\n\n----------\n//定异常不回滚\n@Transactional(noRollbackFor=ArithmeticException.class)\n\n\n")])])]),a("ul",[a("li",[a("h6",{attrs:{id:"主动抛出运行时异常-能回滚。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主动抛出运行时异常-能回滚。"}},[t._v("#")]),t._v(" 主动抛出运行时异常，能回滚。")]),t._v(" "),a("p",[a("code",[t._v("throw new RuntimeException(e)")]),t._v("\n开发过程中这个使用的比较多。或者直接不加try-catch保障数据的原子性。")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t@Transactional\n\tpublic void save(User user) {\n\t\ttry {\n\t\t\tmapper.save(user);\n\t\t\tint i=1/0;\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e); \n\t\t}\n\n\t}\n")])])]),a("ul",[a("li",[a("h6",{attrs:{id:"编程式实现主动回滚"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编程式实现主动回滚"}},[t._v("#")]),t._v(" 编程式实现主动回滚")]),t._v(" "),a("p",[a("code",[t._v("TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();")])])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@Transactional(propagation=Propagation.REQUIRED)\n\tpublic boolean delete(int id) {\n\t\tboolean result = mapper.delete(id);\n\t\tTransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); \n\t\treturn result;\n\t}\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"事务的传播级别-qwe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务的传播级别-qwe"}},[t._v("#")]),t._v(" 事务的传播级别"),a("a",{attrs:{href:"https://www.cnblogs.com/zhangqian1031/p/6542037.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("^qwe"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("当有特殊的需求是，往往一个服务方法里面调用了其他的服务方法，形成一个链状的调用顺序。\n事务的传播级别就是针对这个问题的。\n"),a("code",[t._v("七种传播级别")]),t._v(" "),a("code",[t._v("propagation_requierd")]),t._v("：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。\npropagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。\npropagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。\npropagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。\npropagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\npropagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。\npropagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作")]),t._v(" "),a("blockquote",[a("p",[t._v("Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()->Service2#method2()->Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。")])]),t._v(" "),a("p",[a("strong",[t._v("springboot 默认方法执行完成提交事务。无论是mapper插入还是service都无法直接查询到，事务未提交。")])]),t._v(" "),a("p",[a("strong",[t._v("默认可以读自己的事务内的未提交记录。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);