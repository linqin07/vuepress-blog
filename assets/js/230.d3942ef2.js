(window.webpackJsonp=window.webpackJsonp||[]).push([[230],{453:function(t,e,r){"use strict";r.r(e);var _=r(2),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"mysql事务基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql事务基础","aria-hidden":"true"}},[t._v("#")]),t._v(" MYSQL事务基础")]),t._v(" "),r("p",[t._v("redolog: innodb层面，主要记录事务对"),r("code",[t._v("数据页")]),t._v("做了那些修改，再把redobuffer刷盘到磁盘的redolog文件，保证持久性。只恢复内存刷盘到redolog的数据，记录数据的物理变化")]),t._v(" "),r("p",[t._v("undolog:  用于事务回滚以及MVCC多版本控制。保证原子性")]),t._v(" "),r("p",[t._v("binlog: 记录数据更改所有操作，记录数据的逻辑变化（sql）。主要用于数据恢复全部、数据库主从配置。")]),t._v(" "),r("h3",{attrs:{id:"_1-redo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-redo-log","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.redo log")]),t._v(" "),r("p",[t._v("保证事务的原子性和持久性，避免内存中的脏数据写入数据表 IBD 文件，针对的是内存中数据页的修改操作。")]),t._v(" "),r("p",[t._v("执行sql，写入数据到内存中的 redo log buffer，根据一定规则写入磁盘 redo log，数据库故障时通过 redo log 进行恢复到 idb 文件。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://blog-07.oss-cn-guangzhou.aliyuncs.com/picBak/image-20220210000236061.png",alt:"Redo Log buffer 写入到日志 redo log 示意图"}})]),t._v(" "),r("h4",{attrs:{id:"刷盘规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#刷盘规则","aria-hidden":"true"}},[t._v("#")]),t._v(" 刷盘规则")]),t._v(" "),r("p",[t._v("用户空间的 redo log buffer 写入磁盘 redo log 需要进过系统内核 os buffer，刷盘可以根据下面规则。")]),t._v(" "),r("ul",[r("li",[t._v("事务 commit 就刷盘(默认)")]),t._v(" "),r("li",[t._v("每秒都刷盘")]),t._v(" "),r("li",[t._v("log buffer 占用内存达一定百分比就刷盘")]),t._v(" "),r("li",[t._v("事务中存在检查点时。")])]),t._v(" "),r("h4",{attrs:{id:"redo-log写入规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log写入规则","aria-hidden":"true"}},[t._v("#")]),t._v(" redo log写入规则")]),t._v(" "),r("p",[t._v("把 redo buffer 的写入redo log 中，redo log 中存在两个东西，一个是 wirte pos 记录着数据表记录的位置，另一个是 check point 检查点负责擦除。存在间隔代表还可以继续记录新的操作。")]),t._v(" "),r("h4",{attrs:{id:"lsn"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lsn","aria-hidden":"true"}},[t._v("#")]),t._v(" LSN")]),t._v(" "),r("p",[t._v("表示日志的逻辑序列号。")]),t._v(" "),r("h3",{attrs:{id:"_2-undo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-undo-log","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.undo log")]),t._v(" "),r("p",[t._v("用于回滚事务和多版本控制MVCC，记录逻辑日志，每次执行 sql 增加一条回滚 SQL 语句。比如新增语句 insert 时记录一条 delete 语句，执行 update 语句时记录一条反向的 update 语句。如果数据库崩溃，"),r("code",[t._v("先恢复 redo log")]),t._v(" 再恢复 undo log。")]),t._v(" "),r("h4",{attrs:{id:"mvcc（multi-version-concurrent-control）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvcc（multi-version-concurrent-control）","aria-hidden":"true"}},[t._v("#")]),t._v(" MVCC（Multi-Version Concurrent Control）")]),t._v(" "),r("p",[t._v("MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的"),r("code",[t._v("快照")]),t._v("。")]),t._v(" "),r("p",[t._v("我们每⾏数实际上隐藏了两列，创建时间版本号，过期(删除)时间版本号，每开始⼀个新的事务，版本号\n都会⾃动递增。查询 select 不会更新版本号，但是插入 insert，更新 update， 删除 delete 会更新版本号。")]),t._v(" "),r("h3",{attrs:{id:"_3-binlog"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-binlog","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.binlog")]),t._v(" "),r("p",[t._v("mysql 自身的二进制日志，主要用于主从复制和数据恢复。一个事务的 binlog 是完整的不会插入其他事务的 binlog。")]),t._v(" "),r("p",[t._v("拥有3个记录模式：")]),t._v(" "),r("ul",[r("li",[t._v("row 模式\n每一行操作都记录，日志会很庞大")]),t._v(" "),r("li",[t._v("statement 模式\n不记录细节，只"),r("code",[t._v("记录结果")]),t._v("，有些 sql 如 now(), last_insert_id() 等会不一致。")]),t._v(" "),r("li",[t._v("混合模式\n上面两种结合")])]),t._v(" "),r("p",[t._v("binlog 和 redo log 的区别")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("redolog")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("binlog")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("innodb特有")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("mysql本身就有")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("记录内存中的"),r("code",[t._v("数据页")]),t._v("修改")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("记录所有操作")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("先写缓存区，写入完成提交事务")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("每个sql写入内存缓存或者一个事务提交一次性写入内存缓存")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("循环写日志，通过记录检查点和write pos")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("一直追加写入")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("用于数据库崩溃自动恢复")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("用于主从和数据恢复")])])])]),t._v(" "),r("h3",{attrs:{id:"_4-事务执行流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-事务执行流程","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.事务执行流程")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://blog-07.oss-cn-guangzhou.aliyuncs.com/picBak/image-20220427005435091.png",alt:"事务执行流程"}})]),t._v(" "),r("ol",[r("li",[t._v("查询数据表中待更新的数据到内存中")]),t._v(" "),r("li",[t._v("将缓存中的数据加载到 "),r("code",[t._v("innodb 缓存区")])]),t._v(" "),r("li",[t._v("记录 redo log 到 redo log buffer")]),t._v(" "),r("li",[t._v("记录 undo log 到 undo log buffer")]),t._v(" "),r("li",[t._v("更新内存数据")]),t._v(" "),r("li",[t._v("提交事务触发 redo log 刷盘")]),t._v(" "),r("li",[t._v("undo log 通过检查点机制刷盘")])]),t._v(" "),r("h3",{attrs:{id:"_5-xa事务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-xa事务","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.XA事务")]),t._v(" "),r("p",[t._v("用于支持不同数据库(实数据库例）直接实现分布式事务。")]),t._v(" "),r("p",[t._v("事务管理器： 用于生成不同分支上面的事务")]),t._v(" "),r("p",[t._v("资源管理器：提供对事务的访问能力，实际上一个数据库就可以看作一个资源管理器。")]),t._v(" "),r("p",[t._v("两段提交：")]),t._v(" "),r("ul",[r("li",[t._v("prepare阶段\n事务管理器想资源管理器发送准备指令，")]),t._v(" "),r("li",[t._v("commit 阶段")])])])}),[],!1,null,null,null);e.default=a.exports}}]);