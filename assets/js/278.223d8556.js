(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{502:function(t,a,e){"use strict";e.r(a);var r=e(2),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"模板方法模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 模板方法模式")]),t._v(" "),e("h3",{attrs:{id:"基本方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本方法")]),t._v(" "),e("p",[t._v("基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。")]),t._v(" "),e("p",[t._v("● "),e("strong",[t._v("抽象方法")]),t._v("：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。")]),t._v(" "),e("p",[t._v("● "),e("strong",[t._v("具体方法")]),t._v("：一个具体方法由抽象类声明并实现，而子类并不实现或置换。")]),t._v(" "),e("p",[t._v("● "),e("strong",[t._v("钩子方法")]),t._v("：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。")]),t._v(" "),e("p",[t._v("在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。")]),t._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("1.创建一个抽象类，并实现部分公共抽象接口。实现一个接口，实现接口调用抽象方法。")]),t._v(" "),e("p",[t._v("2.子类实现抽象类的其他抽象接口。")]),t._v(" "),e("p",[t._v("3.使用：由工厂提供的子类进行调用接口方法。")])])}),[],!1,null,null,null);a.default=s.exports}}]);