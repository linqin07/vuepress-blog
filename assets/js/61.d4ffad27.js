(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{456:function(t,a,r){"use strict";r.r(a);var s=r(20),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"集合直接的对应关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集合直接的对应关系"}},[t._v("#")]),t._v(" 集合直接的对应关系")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://blog-07.oss-cn-guangzhou.aliyuncs.com/picBak/1551253158598.png",alt:"1551253158598.png"}})]),t._v(" "),a("h6",{attrs:{id:"_1-list-和-set-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-list-和-set-区别"}},[t._v("#")]),t._v(" 1.List 和 Set 区别")]),t._v(" "),a("ul",[a("li",[t._v("List:有序。可以add null。可以重复插入。")]),t._v(" "),a("li",[t._v("Set：无序。只能一个null。不允许重复对象。")])]),t._v(" "),a("h6",{attrs:{id:"_2-list-和-map-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-list-和-map-区别"}},[t._v("#")]),t._v(" 2.List 和 Map 区别")]),t._v(" "),a("ul",[a("li",[t._v("list 继承 collection 接口，map 是个顶级接口。")])]),t._v(" "),a("h6",{attrs:{id:"_3-arraylist-与-linkedlist-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-arraylist-与-linkedlist-区别"}},[t._v("#")]),t._v(" 3.Arraylist 与 LinkedList 区别")]),t._v(" "),a("ul",[a("li",[t._v("ArrayList底层是数组结构。LinkedList底层是链表。")]),t._v(" "),a("li",[t._v("数组的特性查询快，增删慢。链表的特性是增删快，查询慢。")])]),t._v(" "),a("blockquote",[a("p",[t._v("LinkedList 属于队列：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th",[a("em",[t._v("抛出异常")])]),t._v(" "),a("th",[a("em",[t._v("返回特殊值")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[t._v("插入")])]),t._v(" "),a("td",[a("code",[t._v("add(e)")])]),t._v(" "),a("td",[a("code",[t._v("offer(e)")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("移除")])]),t._v(" "),a("td",[a("code",[t._v("remove()")])]),t._v(" "),a("td",[a("code",[t._v("poll()")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("检查")])]),t._v(" "),a("td",[a("code",[t._v("element()")])]),t._v(" "),a("td",[a("code",[t._v("peek()")])])])])])]),t._v(" "),a("h6",{attrs:{id:"_4-arraylist-与-vector-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-arraylist-与-vector-区别"}},[t._v("#")]),t._v(" 4.ArrayList 与 Vector 区别")]),t._v(" "),a("ul",[a("li",[t._v("Vector是线程安全的。ArrayList不是线程安全的。所以性能上面ArrayList比Vector快。")]),t._v(" "),a("li",[t._v("ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。")])]),t._v(" "),a("h6",{attrs:{id:"_5-hashmap-和-hashtable-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-hashmap-和-hashtable-的区别"}},[t._v("#")]),t._v(" 5.HashMap 和 Hashtable 的区别")]),t._v(" "),a("ul",[a("li",[t._v("HashMap线程不安全，Hashtable线程安全。")]),t._v(" "),a("li",[t._v("HashMap并允许使用 null 值和 null 键。Hashtable不允许。")])]),t._v(" "),a("h6",{attrs:{id:"_6-hashmap-和-concurrenthashmap-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-hashmap-和-concurrenthashmap-的区别"}},[t._v("#")]),t._v(" 6.HashMap 和 ConcurrentHashMap 的区别")]),t._v(" "),a("ul",[a("li",[t._v("ConcurrentHashMap 就是分段的 hashmap，分段对小的片段进行同步，可以提高效率。")])]),t._v(" "),a("h6",{attrs:{id:"_7-hashmap-的工作原理及代码实现-什么时候用到红黑树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-hashmap-的工作原理及代码实现-什么时候用到红黑树"}},[t._v("#")]),t._v(" 7.HashMap 的工作原理及代码实现，什么时候用到红黑树")]),t._v(" "),a("ul",[a("li",[t._v("jdk8 前：计算增加对象key的hashcode，根据hashcode放到对应的桶（bucket）下面，如果已经有了值（发生了碰撞），则新建链表增加。（链地址法）")]),t._v(" "),a("li",[t._v("jdk8：果发现链表长度"),a("code",[t._v("超过 8")]),t._v("，那么将链表转储成红黑树，小于 6 转换回链表形式。小于八，新增成本低。大于八，查询成本低。")])]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("当桶数组 table 为空时，通过扩容的方式初始化 table")]),t._v(" "),a("li",[t._v("查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值")]),t._v(" "),a("li",[t._v("如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树")]),t._v(" "),a("li",[t._v("判断键值对数量是否大于阈值，大于的话则进行扩容操作")])])]),t._v(" "),a("ul",[a("li",[t._v("当数组的使用率超过负载因子的时候（默认值是0.75）便会选择扩容，扩容两倍。")])]),t._v(" "),a("h6",{attrs:{id:"_8-多线程情况下hashmap死循环的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-多线程情况下hashmap死循环的问题"}},[t._v("#")]),t._v(" 8.多线程情况下HashMap死循环的问题")]),t._v(" "),a("ul",[a("li",[t._v("使用hashtable，并发高使用ConcurrentHashMap")])]),t._v(" "),a("h6",{attrs:{id:"_9-concurrenthashmap-的工作原理及代码实现-如何统计所有的元素个数-减少集合的粒度-更高效的利用。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-concurrenthashmap-的工作原理及代码实现-如何统计所有的元素个数-减少集合的粒度-更高效的利用。"}},[t._v("#")]),t._v(" 9.ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数,减少集合的粒度，更高效的利用。")]),t._v(" "),a("ul",[a("li",[t._v("把hashmap细分为多个子集，增加并发能力。")])]),t._v(" "),a("h6",{attrs:{id:"_10-iterator和listiterator的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-iterator和listiterator的区别是什么"}},[t._v("#")]),t._v(" 10.Iterator和ListIterator的区别是什么？")]),t._v(" "),a("ul",[a("li",[t._v("Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。")]),t._v(" "),a("li",[t._v("Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。\n其他的差不多。")])]),t._v(" "),a("h6",{attrs:{id:"_11-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么"}},[t._v("#")]),t._v(" 11.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？")]),t._v(" "),a("p",[t._v("情景：多线程使用迭代器进行迭代过程中其他线程修改了集合的值。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("默认就是快速失败：\n抛出异常Concurrent Modification Exception。\n迭代器是直接在原来的集合上进行迭代。")])]),t._v(" "),a("li",[a("p",[t._v("安全失败：\n会额外复制一份集合的值出来进行迭代，不会抛出异常，使用"),a("code",[t._v("并发包下面的集合类")]),t._v("都是安全失败的。缺点是修改值不能通知到自己。")])])]),t._v(" "),a("h6",{attrs:{id:"_12-enumeration接口-out没人用-和iterator接口的区别有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-enumeration接口-out没人用-和iterator接口的区别有哪些"}},[t._v("#")]),t._v(" 12.Enumeration接口(out没人用)和Iterator接口的区别有哪些？")]),t._v(" "),a("ul",[a("li",[t._v("Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。")])]),t._v(" "),a("h6",{attrs:{id:"_13-hashset和treeset有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-hashset和treeset有什么区别"}},[t._v("#")]),t._v(" 13.HashSet和TreeSet有什么区别？")]),t._v(" "),a("ul",[a("li",[t._v("hashset 无序，添加删除复杂度都是O(1)")]),t._v(" "),a("li",[t._v("hashtree 有序，添加删除复杂度都是O(logn)")])])])}),[],!1,null,null,null);a.default=e.exports}}]);