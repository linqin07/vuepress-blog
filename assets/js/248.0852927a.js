(window.webpackJsonp=window.webpackJsonp||[]).push([[248],{470:function(a,t,i){"use strict";i.r(t);var r=i(2),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,i=a._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[i("h3",{attrs:{id:"为什么接口要实现impl"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#为什么接口要实现impl","aria-hidden":"true"}},[a._v("#")]),a._v(" 为什么接口要实现Impl")]),a._v(" "),i("h6",{attrs:{id:"_1-解耦"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-解耦","aria-hidden":"true"}},[a._v("#")]),a._v(" 1.解耦")]),a._v(" "),i("p",[a._v("抽象出service层也是为了更好的控制"),i("code",[a._v("事务")]),a._v("吧，将持久化和业务分开。")]),a._v(" "),i("h6",{attrs:{id:"_2-面向接口编程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-面向接口编程","aria-hidden":"true"}},[a._v("#")]),a._v(" 2.面向接口编程")]),a._v(" "),i("h6",{attrs:{id:"_3-代理方式"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-代理方式","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.代理方式")]),a._v(" "),i("p",[a._v("一、简单来说：")]),a._v(" "),i("ul",[i("li",[a._v("JDK 动态代理只能对实现了接口的类生成代理，而不能针对类")]),a._v(" "),i("li",[a._v("CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）")])]),a._v(" "),i("p",[a._v("二、Spring在选择用JDK还是CGLiB的依据：")]),a._v(" "),i("ul",[i("li",[a._v("Bean实现接口时，Spring就会用JDK的动态代理")]),a._v(" "),i("li",[a._v("当Bean没有实现接口时，Spring使用CGlib是实现")])]),a._v(" "),i("p",[a._v("三、CGlib比JDK快？")]),a._v(" "),i("ul",[i("li",[a._v("使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。")]),a._v(" "),i("li",[a._v("在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);